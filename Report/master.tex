%\documentclass[11pt]{report}
%\usepackage[a4paper]{geometry}
\input{prelude}

%%%%%%%%%%%%%%%%%%
% BEGIN DOCUMENT %
%%%%%%%%%%%%%%%%%%

%\usepackage[final]{listings}

%\input{csvfiles}

\begin{document}

\maketitle
%\frontmatter
%\makedecl
\input{acknowledgement}
%\include{abstract}
%\mainmatter
%\setcounter{tocdepth}{3}
%\setcounter{secnumdepth}{3} dunno what this does.
{
  \hypersetup{linkcolor=black}
  \tableofcontents
  % Two times compilation
  %\listoffigures
  %\listoftables
   
}
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Intro
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction}
%%%%%%%%%%% PARSER %%%%%%%%%%%
\section{Problem description and motivation}
Railway companies need to continuously and sufficiently maintain the train tracks and optimally detect defects in order to have a more punctual and more effective train system. However, the current system is expensive, time consuming and ineffective. That is, maintenance agents need to walk along tracks and check them for defects. For visualisation purposes, there is roughly 5200 km of rails in Switzerland which needs to be inspected by 40 experienced inspectors.


In order to cope with this issue, Swiss Federal Railways (SBB) has specifically built two new diagnostic vehicles designed for defect identification among other purposes. For this, two accelerometers have been installed at the front and back of the vehicle to collect the signal responses from the wheel and the train track
\todo{insert picture, mention boogey?}

A defect in train tracks can be seen as a discontinuity. As a train passes over this discontinuity, it will result in a perturbation that can be detected by sensors. It is our main assumption that each type of defect will have a specific signature that will allow its identification and classification. This is similar to the idea presented in \todo{https://blog.goodaudience.com/introduction-to-1d-convolutional-neural-networks-in-keras-for-time-sequences-3a7ff801a2cf}

By succesfully identifying and classifying the defects, we take one step further towards reducing delays and making trains more punctual and reliable. The first step in this process consists of identification and classification, while the second step consists of future defect prediction.

\section{Objective}
The objective 

\section{Defects}
Evidently, a defect can be seen as a deviation from the standard train track. For the exact defect type, SBB has self-constructed a database for the individual defect definitions \todo{is this a recognized system?}. Here is a few examples:


Generally, a defect can be split into two overarching types: line-defects and type-defects. For this project
SBB has done the classification themselves
Defect can be of any type, which defects do we want to focus on
\todo{insert pictures}

\section{Data}
Data is provided by SBB

\section{Code}
The code can be found on github: \url{sdds}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Design and implementation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Design and Implementation}
First we need to analyse the data, show a few defects and their signals \todo{appendix for more signals?}


\section{Peak windows}
To find,
we can change the parameters for the peak findings
\section{Neural network architecture}

Trained a neural network, although we were only able to achieve max
Based on the analysis we

\section{Visualisation}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Evaluation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Evaluation}
\section{Results}
\section{Discussion}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Conclusion and future work
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Conclusion and future work}
\section{Conclusion}
\section{Future work}

\begin{itemize}
	\item
\end{itemize}

\begin{itemize}
	\item 
\end{itemize}


\newpage
\section{TODO}
\begin{itemize}
	\item very fast speed, overlap between switch and ins, old vs new rail, ax1 arrow 2 arrow 3 arrow 4
	\item 3D plots?
	\item change the defect library to use pandas instead?
	\item visualise what the network is doing using Harry's code
	\item use speed as a feature also
\end{itemize}


\newpage
\section{Notes}
1D convolution tutorial
Height = acc length
Width = the number of features
Output is determined by kernnel size and height of data

Misc:
\begin{itemize}
	\item \verb|pd.options.display.max_rows = 15|
	\item \verb|#np.bincount(y.class_label.values)/4 where does 151.5 coem from??|
\end{itemize}

whats this
\begin{minted}{python}
def conv(df):
    """
    has to be series
    """
    return np.vstack([v for v in df])

dup_ins = s_features.ins_joints.copy()[['accelerations']]
dup_swi = s_features.switches.copy()[['accelerations']]
dup_def = s_features.defects.copy()[['accelerations']]

dup_ins['accelerations'] = np.sum(conv(dup_ins.accelerations),1)
dup_swi['accelerations'] = np.sum(conv(dup_swi.accelerations),1)
dup_def['accelerations'] = np.sum(conv(dup_def.accelerations),1)

# s_features.ins_joints[['vehicle_speed(m/s)', 'Axle', 'campagin_ID']].duplicated() or

idx_ins = dup_ins.accelerations.duplicated()
idx_swi = dup_swi.accelerations.duplicated()
idx_def = dup_def.accelerations.duplicated()
new_ins = s_features.ins_joints[~idx_ins]
new_swi = s_features.switches[~idx_swi]
new_def = s_features.switches[~idx_def]

print("Duplcated samples: ", len(dup_ins) - len(new_ins))
print("Duplcated samples: ", len(dup_swi) - len(new_swi))
print("Duplcated samples: ", len(dup_def) - len(new_def))

# Load weight example 
# Could just save entire model and then load entire model
# Could also make this into a function
clf2 = NN(N_FEATURES, N_CLASSES)
clf2.prepare_data(X, y)
clf2.make_model2()
clf2.load_weights('model_01-12-2019_150004.hdf5')
clf2.predict() ### on validation set
clf2.measure_performance(accuracy_score)
\end{minted}

Test sample
\begin{minted}{python}
ii = pd.DataFrame([
    [np.array([1,2]),2], 
    [np.array([1,2]),2], 
    [np.array([1,2]),2]])
    
    
x = a
[u,I,J] = unique(x, 'rows', 'first')
hasDuplicates = size(u,1) < size(x,1)
ixDupRows = setdiff(1:size(x,1), I)
dupRowValues = x(ixDupRows,:)

s_features.ins_joints.timestamps[:2].duplicated()
\end{minted}

\chapter{Appendix}
\todo{Figure out references}
\todo{New paper with train}

\newpage
\cleardoublepage
\appendix
\chapter{Appendix}
\label{code}
\inputminted[linenos, fontsize = \scriptsize]{haskell}{../src/utils/defect_utils.py}

\end{document}
